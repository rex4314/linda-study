# Definition :: for novice developer 

## 1. ERP (Enterprise Resource planning)
- 전사적 자원 관리 시스템
- 기업의 모든 자원을 전체적으로 관리하여 최적화된 기업 활동을 통합, 관리 시스템에 근거하여 스피드 경영과 투명 경영의 효과를 꾀하는 것
  
## 2. Framework
- 특정 형태의 소프트웨어 문제를 해결하기 위해, 상호 협력하는 클래스들과 인터페이스의 집합
- 장점 : 재사용성, 단순성, 역할구분, 확장성, 유지보수 용이 
- 라이브러리와 프레임워크의 차이
  - 라이브러리는 어플리케이션에서 호출할 수 있는 함수와 루틴으로 구성되어 있음
  - 프레임워크는 어플리케이션에서 특정 기능들을 제공하기 위해 확장할 수 있는 일반적이고 상호 협력적인 컴포넌트를 제공

## 3. DI, AOP.
- DI  : Dependency injection = 의존성 주입
  - Spring을 적용하여 applicationContext.xml에서 설정만 해주면 외부 설정파일(xml)에서 연관관계에 있는 객체를 주입해주기 때문에 의존객체를 찾기 위한 코드가 필요하지 않게 됨
  - 즉, 외부설정에서 객체를 찾아서 쓰기 때문에 코드 내에 의존관계를 맺는 코드 생성이 불필요
  
- AOP : Aspect oriented programming = 약자 관심지향 프로그래밍
  - 프로그래밍 할 때 특정한 관심사를 가진 코드 부분을 별도의 모듈로 분리함으로써 기존 객체지향의 강력한 기능(상속, 위임)만으로는 처치가 곤란했던 중복을 할 수 있게 됨
 
## 4. Spring
- Java Enterprise Application 개발에 사용되는 Application Framework : 
  - 빠르고 효율적인 개발을 할 수 있도록 Application의 바탕이 되는 틀과 공통프로그래밍 모델, 기술 API를 제공
- 특징
  - 스프링은 종속 객체주입이라는 기술을 통해 낮은 결합도를 유지할 수 있음
  - AOP를 이용하여 객체지향만이 아닌 관심지향 기법을 활용
  - EJP 기능을 대체할 수 있음. 트랜잭션 처리를 위한 일관된 방법을 제공
  - 레이어간 연결이 interface로 이어지기 때문에 interface 생성이 필요
  - 다양한 프레임워크와의 통합
- MVC 모델에서 커버하는 부분 : Controller 지원
- 실행 순서 (실행 구조)
  -  web.xml의 등록된 DispatcherServiet를 통해서 요청에 대해 진입
  -  DispatcherServiet은 Client로부터 들어온 URL을 HandlerMapping이라는 곳으로 전송 후, URL을 분석하여 알맞은 Controller 이름을 다시 DispatcherServiet로 보냄
  -  HandlerMapping이라는 것을 통해서 실행될 Controller의 이름을 입력 받은 DispatcherServiet은 전달받은 Controller를 실행함
  - 이렇게 실행된 Controller는 스프링에서 제공하는 ModelAndView 객체에 View Page에 전달할 객체와 View Page 이름 정보를 담고 DispatcherServiet로 보냄.
  -  ViewResolver를 통해 보일 View Page를 탐색한 후, View Page를 보여줌
 
## 5. iBatis / myBatis
- Java에서 Database를 편하게 Handling 할 수 있게 해주는 Framework
- 특징
  -  SQL문과 Java코드와의 분리만으로도 Java개발자는 Query문을 신경 쓰지 않아도 됨.
  - SQL문이 변경되더라도 파라미터 값이 변경되지 않는다면 Java소스에서 수정부분이 없기 때문
- MVC 모델에서 커버하는 부분 : Model 지원
- 실행 순서 (실행 구조)
  - 자바코드 내에서 특정 쿼리문을 실행하기 원할 때, 파라미터와 필요한 조건을 넘기기 위한 객체 생성
  - SQLMaps를 실행하기 위해 쿼리의 객체와 이름을 넘겨줌
  - 쿼리가 실행되었을 때 SQLMaps는 쿼리 결과를 받기위해 정의된 클래스의 인스턴스를 생성하게 됨
  - 인스턴스는 데이터베이스에 의해 반환된 Resultset으로부터 만들어짐
 
## 6. MVC 패턴이란?
- Model, View, Control의 역할을 확실하게 분리시켜 놓는 프로그래밍 기법
 
## 7. WAS (Web Application Server)
- Server와 Client 사이에 있는 3-tier 방식으로서, Server가 처리하는 양이 많아지면서 Server에 생기는 부하를 해결하기 위해 개발
- Client에서 요청이 들어오면 실제적인 처리는 WAS가 하고 Server는 단지 Client에 결과 값을 뿌려주는 역할만 하게 됨
- 대표적인 제품 : 톰캣, 웹스피어, 웹로직, 제우스 등
  
## 8. String, StringBuffer, StringBuilder의 차이점
- String 클래스 : 상수 문자열, 한번 생성한 후 변하지 않는 문자열 용도
- StringBuffer 클래스 : 프로그램 내에서 계속 변하는 문자열 용도
- StringBuilder 클래스 : Java5에 추가된 클래스로 StringBuffer와 기능이 같다.
- 차이점 : 
  - StringBuffer는 동기화(synchronized)되지만 StringBuilder는 그렇지 않다.
  - 즉, StringBuilder는 다중 thread에서는 안전하지 않으므로 동기화가 필요한 경우는 StringBuffer를 사용하는 것이 좋다. 
  - StringBuilder에서 동기화 하려면 synchronized블록으로 감싸야 한다.
  
## 9. Java Servlet
- 자바를 사용하여 웹페이지를 동적으로 생성하는 서버 측 프로그램
 
## 10. JSP란?
- Java Server Page : 자바를 기반으로 하는 스크립트 언어
- 특징
  - 자바를 기반으로 하는 스크립트 언어로서 자바의 장점을 사용할 수 있음
  - 자바를 기반으로 하고 있으므로 플랫폼에 상관없이 사용할 수 있음
  - 표현언어, 표현식, 스크립틀릿 등의 다양한 스크립트 요소와 액션 태그 등을 제공함으로써 보다 쉽게 웹 어플리케이션을 개발할 수 있음
  - 서블릿/EJB 등의 엔터프라이즈 기술들과 잘 융합됨
  
## 11. JSP를 구동하기 위해 서버를 구축하는 과정
- 자바 인스톨
  - JDK 인스톨
  - JRE 인스톨 (JDK를 설치하면 설치가 되므로 따로 설치할 필요 없음) 
- 환경변수 setting : 컴퓨터의 환경변수(Path)를 잡아야 함
- 미들웨어 : JSP를 웹으로 변환해 줄 수 있는 톰켓 설치

## 12. XML이란?
- 사용자 정의 태그를 통해 텍스트 데이터의 구조화된 문서 저장과 application간의 문서교환을 위해 1986년 ISO에 제안된 마크업 언어
- SGML의 일부 기능과 인터넷에서 이용하기 쉬운 HTML의 장점을 도입하여 개발한 언어
- 특징
  - 사용자 정의 태그가 가능
  - 텍스트 데이터을 구조화하고 전송할 목적(텍스트 데이터의 재사용과 정보 검색 용이)
  - Application  and WepApplication 모두 사용 가능

## 13. 서블릿 (Servlet)
- 서버용 애플릿, 웹서버에서 실행되는 작은 자바 코드
- JVM에서 실행되므로 플랫폼의 구애를 받지 않고, 웹서버와 충돌이 없고 메모리 관리가 철저함
- 웹 브라우저에서 실행되지 않고 GUI로 구성되지 않는다는 점이 애플릿과 다름
- 웹서버에서 실행되는 서블릿 엔진과 서비스 요청 및 이에 대한 반응 형태로 사용

## 14. Applet
- 자바 애플릿 프로그램은 애플릿 뷰어(JDK에 포함)나 www(웹)검색기(웹 브라우저)에 의해서 실행되는 작고 간단한 프로그램
- 일반적으로 애플릿 프로그램은 인터넷과 연동된 웹 서버로부터 사용자의 컴퓨터로 다운로드 되어 검색기 상에서 실행
- 애플릿 프로그램은 실행명령에 의해 실행되지 않고 웹의 HTML 코드 내에서 호출되는 실행되는 형태

## 15. 자바의 특징
- 플랫폼에 독립적인 객체지향 언어
- 플랫폼에 독립적이라는 것은 리눅스 그리고 윈도우 등과 같은 개발환경에 제약을 받지 않고, 어느 플랫폼에서나 코드의 호환성과 재사용이 자유롭다는 것을 의미

## 16. 객체(object)
- 효율적으로 정보를 관리하기 위하여 사람들이 의미를 부여하고 분류하는 논리적인 단위
- 프로그래밍에서는 클래스에 정의된 내용대로 메모리에 생성된 것

## 17. 클래스
- 객체를 만드는 설계도 (객체를 생성하는 틀의 개념)

## 18. 객체와 인스턴스
- 클래스로부터 객체를 만드는 과정을 클래스의 ‘인스턴스화’라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 ‘인스턴스’라고 함
  
## 19. 객체지향 프로그래밍(Object-Oriented Programming : OOP)
- 컴퓨터 프로그래밍의 패러다임의 하나
- 객체지향 프로그래밍(OOP)은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 “객체”들의 모임으로 파악하고자 하는 것.
- 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있음.
- 캡슐화(Encapsulation): 
  - 하나의 문제 해결을 위한 data와 method를 한 단위로 묶는 것으로서, 클래스 내부 정의에 대해 외부에서 볼 수 없도록 함이 특징(은닉화)
- 추상화(Abstraction) : 
  - 객체(Object)의 자세한 성질을 무시하고(숨기고) 그들의 일반적인 성질을 나타낸다는 것
  - 일반적으로 클래스는 클래스로 표현할 서브클래스(또는 객체)의 공통적인 성질과 행위를 일반화해 디자인되며 그로부터 생성된 객체는 자신의 고유한 성질을 갖게 됨
- 다형성(Polymorphism) : 
  - 다형성이란 같은 메시지에 대해 클래스에 따라 다른 행위를 하는 특성
  - 일반적으로 같은 이름을 갖는 method에 대해 인자(Argument) 개수와 Data Type에 따라 수행되는 행위가 달라짐을 의미
  - 다형성을 통해 사용자는 약속된 인터페이스를 따르는 서로 다른 객체들을 같은 방식으로 사용할 수 있게 됨
 - 상속(inheritance) : 
   - 기존에 있던 클래스(즉, 기존의 클래스로부터 상속받은)를 바탕으로 다른 특성을 추가해 새로운 클래스를 만들 수 있음
- 인스턴스(Instance) : 
  - 인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿(무엇인가를 만들 때 안내 역할 하는 데 사용되는 형식, 꼴, 틀 또는 모형 등을 의미)이 실제로 구현된 것

## 20. 자바언어와 기존의 언어의 다른 특징
- 포인터를 사용하지 않음 (포인터는 존재, 연산을 허용하지 않음)
- 자동으로 쓰레기 수집(garbage collection) 기능을 수행
- 엄격한 형 검사(strict type checking)를 수행하여 에러를 조기에 발견
- 실행시간에 발생하는 에러를 처리

## 21. 다형성
- 객체지향 개념에서의 다형성이란 ‘여러 가지 형태를 가질 수 있는 능력’을 의미하며 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 창조할 수 있도록 함으로써 다형성을 프로그램적으로 구현
  
## 22. Overloading, Overriding
- Overloading (method 중복정의)
  - 기존의 method 인자를 이용하여 하나의 함수에 여러 가지 기능을 만드는 것
- Overriding (method 재정의)
  - 상위 클래스에 있는 method와 똑같은 method를 하위 클래스에 다시 만들기
  - 즉 하위 클래스에서 method를 재정의하는 것
  - 주로 생성자 method를 정의할 때 많이 사용

## 23. API : 자바 API (Application Programming Interface)
- 자바개발 환경에서 제공되는 거대한 패키지
- 자바언어는 작고 단순한 대신 많은 기능들을 제공하는 라이브러리를 API로 가지고 있음

## 24. InnerClass를 쓰는 이유
- 내부 클래스를 사용하면 같은 패키지에 있는 다른 클래스한테 까지도 숨길 수 있기 때문에 outer class를 통하지 않고서는 접근할 수 없음
- 보안성이 좋아짐

## 25. OOL (Object Oriented Language)
- 객체지향 언어
  
## 26. OOP (Object Oriented Programming)
- 객체지향 프로그램
  
## 27. import
- C/C++의 #include 선행처리문과 비슷함
- 헤더파일의 선언을 위해 필요한 구문
- 인터프리터에게 클래스를 띄우라는 지시자의 역할을 함
  
## 28. 예외처리의 필요성과 목적
- 자바에서 프로그램 실행 중 예외가 발생하면 발생된 시점에서 프로그램이 바로 종료됨
- 때에 따라서는 예외가 발생했을 때 프로그램을 종료시키는 것이 바른 판단일 수도 있음
- 하지만 가벼운 예외나 예상을 한 예외라면 프로그램 종료가 조금은 가혹하다고 느낌 
- 그래서 ‘예외처리’라는 수단(mechanism)이 제안되었고 예외 처리를 통해 우선 프로그램의 비정상적인 종료를 막고 발생한 예외에 대한 처리로 정상적인 프로그램을 계속 진행할 수 있도록 하는 것이 예외처리의 필요성
- 예외의 발생으로 실행 중인 프로그램의 갑작스러운 비정상 종료를 막고, 정상 적인 실행 상태를 유지할 수 있도록 하는 것
  
## 29. Abstract 클래스
- 추상 method를 하나 이상 가지는 클래스
- new 객체를 생성할 수 없음
- 상속받은 클래스는 추상 method를 구현해야만 인스턴스를 생성할 수 있음 (추상클래스끼리의 상속은 method 재정의가 필요 없음, 사용할 때 일반 클래스에서 재정의)
- 추상 method란 함수의 리턴 타입과 파라메터만 있고 정의 부분이 없는 함수
  
## 30. 추상화(abstraction)
- 구체적인 개념으로부터 공통된 부분들만 추려내어 일반화할 수 있도록 하는 것을 의미
- 일반적으로 사용할 수 있는 단계가 아닌 아직 미완성적 개념
  
## 31. Interface
- 상수 또는 추상 method만 정의할 수 있음
- 구현된 method는 포함할 수가 없음
- 모든 변수는 static(정태적)이고 final
- 자식클래스들이 공통된 method를 포함하도록 하는 기능만 함
- 다중 상속 가능
  
## 32. 추상클래스와 인터페이스의 공통점
- 객체를 발생시킬 수 없음
- 상속해서 하위 class를 통하여 객체를 발생시킴 (method를 재정의 해야 함)

## 33. 전역변수, 지역변수, 정적변수를 스택과 힙과 관련해서 설명
- 전역 변수
  - 프로그램에서 전반적으로 다 사용이 가능
  - 함수 밖에서 정의해 놓으면 다름 함수에서도 사용할 수 있음
- 지역 변수
  - 함수 안에서만 사용이 가능한 변수
  - 다른 함수에서는 사용을 못함
- 정적 변수
  - 한 번 정의하면 그 값은 계속적으로 메모리에 남아 있음
  - 프로그램이 종료될 때, 메모리에서 지워짐
  - 함수 안에서 사용해도 함수가 끝날 때 지워지지 않음
         
## 34. 스레드(Multi thread)
- 하나의 프로그램이 동시에 하나 이상의 처리(process)를 수행하는 것을 의미
  
## 35. 디버깅
- 버그(결함) 에러를 수정하는 것
  
## 36. 미들웨어 (Middleware)
- 최근에 네트워크 상호 호환과 연동상태를 관리하는 분산 환경에 관심을 갖고 데이터베이스, 스프레드시트, 윈도우 OLE등 다양한 소프트웨어를 다루는 데 더 관심을 가짐
- 이러한 공통의 인터페이스를 준수하는 컴포넌트 기반의 소프트웨어는 많은 장점을 제공함
- 이러한 공통의 인터페이스를 프레임워크=미들웨어(Middleware)라고 함

## 37. Camel Case (변수이름 정하는 규칙)
- 클래스: 첫 문자는 대문자로 시작, 둘 이상 단어 묶어 구성 시 새로 시작 단어 대문자
- 메소드: 첫 문자는 소문자로 시작, 둘 이상 단어 묶어 구성 시 새로 시작 단어 대문자
- 상수: 모든 문자를 대문자로 구성, 둘 이상 단어 연결 시는 _ (언더바)를 사용하여 연결함

## 38. JVM의 구성
- 클래스영역 : 클래스 코드를 저장하는 영역
- 자바 스택 : method를 호출할 때 관련 정보를 저장하는 영역
- 힙(Heap) : new 라는 키워드를 통해 객체가 생성될 때 할당 받는 영역
- 네이티브 method 스택
  
## 39. Collection에서 데이터를 저장하는 3가지와 그 특징
- Set : 순서가 없고, 동일한 데이터 허용 안 됨
- List : 배열과 같은 구조지만, 가변적 길이를 가지고 있음 (크기가 지정 되어있지 않음)
- Map : key 값과 value값의 형식으로 저장되면 key값은 절대 중복이 안 됨
  
## 40. 스트림
- 데이터를 목적지로 입/출력하기 위한 방법
- 스트림에 데이터를 쓸 수 있고 읽을 수 있음
- 연결하고자 하는 Device에 따라 다양한 스트림이 존재
- 스트림은 FIFO 구조, 읽기/쓰기가 동시에 되지 않음
- 읽기, 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을 각각 하나씩 열어 사용해야함
- 데이터가 처리되기 전까지 스트림에 사용되는 스레드는 데이터가 모두 전송되기 전까지 블로킹 상태에 빠짐

## 41. 동기화
- 여러 명이 접근하는 것을 방지하기 위함
- 이때 여러 명이 접근하는 것을 막기 위해 모든 객체에 ‘락’을 포함시키는데, ‘락’이란 공유 객체에 여러 스레드가 동시에 접근하지 못하도록 하기 위한 것으로 모든 객체가 힙 영역에 생성될 때 자동으로 만들어 짐

## 42. 더블 버퍼링을 사용하는 이유
- 이미지를 출력시키는 경우 화면을 지웠다가 다시 그리게 되면 깜박거리게 됨
- 이러한 문제점의 해결을 위해, 화면에 직접 이미지를 그리지 않고 메모리상에 미리 그려 놓고 필요할 때 한번만 화면에 출력시키는 방법으로 출력 시 깜박거림을 최소화시켜 줌
  
## 43. AWT와 Swing의 차이점
- AWT : 
  - Platform에 종속
  - 중량 Component
  - Frame 자체에 분할
  - 범용 Component
- Swing : 
  - Platform에 자유로움
  - 경량 Component
  - Frame 포함 멤버 분할
  - Local Component
  
## 44. Statement 와 PreparedStatement의 차이
- Statement : 
  - 정적 쿼리 시 사용
  - 매번 파싱 과정을 거쳐야 함(부하가 생길 수 있음)
  - SQL문 전체를 명확히 알 수 가 있어서 디버깅이 쉬움
- Prepared Statement : 
  - 동적 쿼리 시 사용
  - 한번 파싱 하면 그 동일 SQL문장을 곧 바로 파싱 과정 없이 Execution 가능(반복적인 다량의 SQL 수행 시 성능 상 이득이 있음)
  - 오류발생 시, 변수에 입력되는 값을 알 수 없어서 디버깅이 어려움
 
## 45. 서블릿의 실행 과정
- 서버가 클라이언트의 연결 요청받음
- 컨테이너는 연결 요청 정보를 담고 있는 Request 객체와 연결 응답 정보를 담고 있는 Response 객체를 생성
- 접수된 URL을 분석 후 해당 서블릿 객체를 생성하고, 사용자의 요청을 처리하기 위해 스레드를 생성 후 service() method에 인자 값을 담아 호출
- service() method는 Request 객체를 참고하여 어떤 연결 요청 방식으로 들어왔는지 파악함(GET 방식인지 POST 방식인지)
- 들어온 요청 방식에 따라 get 방식은 doGet() method를, post 방식은 doPost() method를 호출하여 처리함
- service() method의 인자 값으로 넘겨받은 response 객체를 이용하여 클라이언트에게 결과를 보여줌
- 사용자 요청을 처리하기 위해 생성한 스레드를 소멸
  
## 46. 서블릿에서 데이터를 처리하는 방식
- GET : 
  - 서버에 있는 정보를 가져오기 위해 설계됨. 
  - 240바이트까지 전달할 수 있음
  - POST 방식에 비해 속도가 빠름
  - 검색엔진에서 검색단어 전송에 많이 이용함
  - URL 노출로 보안성이 요구되는 경우엔 사용할 수 없음
- POST : 
  - 서버로 정보를 올리기 위해 설계됨
  - URL에 파라미터가 표시되지 않음
  - 내부적으로 데이터가 이동함
  - GET 방식에 비해 속도 느림. 데이터크기 제한 없음
  
## 47. JSP에서 페이지 이동 방법
- Forward 방식 
  - URL이 바뀌지 않음
  - 요청객체와 응답객체가 유지됨
  - 속도가 빠르며 요청객체에 소속되어 있음
  - 처리 구조
    - 요청이 들어오면 Servlet이 받음
    - 요청에 알맞은 페이지를 찾음
    - 알맞은 페이지가 있다면 응답
    - 알맞은 페이지가 없다면, Forwarding 방식으로 알맞은 페이지로 넘기는데, 요청객체와 응답 객체를 포함해 넘김
    - URL이 바뀌지 않은 상태로 응답 페이지를 통해 응답
- Redirect 방식 
  - URL이 바뀜
  - 요청객체와 응답객체가 유지되지 않음
  - 속도가 느리며, 응답객체에 소속되어 있음
  - 처리 구조 
    - 요청이 들어오면 Servlet이 받음
    - 요청에 알맞은 페이지를 찾음
    - 알맞은 페이지가 있다면 응답
    - 알맞은 페이지가 없다면, 알맞은 페이지로 다시 요청하게끔 응답 보냄
    - 클라이언트는 응답을 받고, 다시 그 요청의 맞는 URL로 요청함
  
## 48. 자바 빈즈(Beans)
- 자바에서 사용하는 컴포넌트(부품)
- Bean은 자바에서 컴포넌트를 이용하기 위해 만들어 놓은 기술
- 컴포넌트를 사용하면 좋은 이유는 필요 할 때마다 가져 다가 사용할 수 있다는 점인데, JSP에서 자바의 컴포넌트를 이용해서 프로그래밍 하는 것을 빈즈 프로그래밍이라 함
  
## 49. Connection Pool 개념
- 미리 생성해 놓은 커넥션을 할당하고 반납함으로써 커넥션 생성 시간을 줄인다는 개념
- 미리 생성할 때 너무 조금 생성하면 오히려 타임 오버헤드가 늘어나고, 반대로 너무 많이 생성하면 메모리 오버헤드가 늘어남

## 50. Model 1 방식 과 Model 2 방식의 특징과 차이점
- Model 1 : 
  - 디자인 코드와 자바 코드(비즈니스 로직)를 구분하지 않고, 하나의 JSP 내에 기술해서 웹 프로그램을 제작하는 방식
  - 개발하기가 쉽고, 배우기가 쉬움
  - 디자인코드와 비즈니스 로직의 구분이 명확하지 않아, 복잡도가 높음
  - 수정 시 디자이너와 개발자의 협업이 필요
  - 비즈니스 로직의 재 사용성이 어려우며, 유지 보수가 힘듦

- Model 2 : 
  - 웹 어플리케이션을 개발할 때, MVC패턴을 적용하여, 웹 어플리케이션의 개발이 가능하도록 구현한 것
  - 초기 설계에 많은 시간이 소요
  - 디자인코드와 비즈니스 로직이 분리되며, 비즈니스 로직의 재사용성이 높아짐
  - 비즈니스 로직 계층의 확장성이 용이하며, 유지보수가 편함
  
## 51. Singleton
- 발전된 형태의 전역 변수
- 프로그램 상에서 두 번째 인스턴스를 만들 수 없게 하는 기능
- 만들어진 클래스의 객체를 단 하나만 사용하며 어디서든 그 객체를 사용가능 하도록 만들어 줌
  
## 52. Cookie와 Session의 차이
- Cookie : 
  - 클라이언트에 정보를 저장하기 때문에 서버에 부하가 없음
  - 사라지는 때(시간)를 지정할 수가 있음
- Session : 
  - 서버에 정보를 저장하기 때문에 서버에 부하가 많이 생김
  - 해당 클라이언트와 일정 시간동안 작용이 없으면 서버메모리에서 해제됨
  - 직접적으로 해제시킬 수 있는 method가 있음
  
## 53. JSP와 자바스크립트의 차이
- JSP는 자바에서 파생된 서버사이드 스크립트로서 웹 페이지를 작성하는데 사용
- 자바스크립트는 클라이언트사이드 스크립트이며, 브라우저의 객체를 제어하는데 쓰임

## 54. 엔티티 빈 (Entity Bean)
- 데이터를 객체화 하여 재사용이 가능한 컴포넌트를 말함
- 데이터의 객체화 란 개발자들이 데이터에 접근, 변경 방법이 보다 단순하고 쉬워진다는 의미
- 객체화 된 데이터를 비지니스 객체 또는 현실 세계의 객체
- 이 객체는 영속성을 가진 관계형 데이터베이스에 저장이 되고, 데이터베이스에서 테이블의 한 레코드와 대응됨
- 여기서 중요한 것은 빈 인스턴스와 데이터베이스의 데이터가 동기화 되어야 한다는 것
- 즉, 빈 인스턴스에서 새로운 변화가 일어날 때마다 데이터베이스도 같이 갱신이 되어야 함
 
## 55. EJB의 사용 목적
- “대규모이고 구조가 복잡한 분산 객체 환경”을 쉽게 구현하기 위해서 등장
- 컴포넌트(클래스들이 모여서 생긴 하나의 기능)들의 재사용을 목적
- Enterprise Bean은 이식성이 좋음

## 56. DBMS(Database Management System)
- 데이터베이스 관리시스템 : 응용프로그램이 데이터에 대한 액세스가 가능하도록 DB를 관리하는 소프트웨어 기능 및 데이터가 저장되어 있는 장소
  
## 57. RDBMS(Relational Database Management System)
- 관계형 데이터베이스 : 
  - 일반적으로 관계형 데이터 모델에 기반한 데이터베이스를 관계형 데이터 베이스라고 함
   - 데이터를 테이블로 표현하고 테이블을 집합으로 받아들임
   - 데이터를 조작하는 데는 집합론에 기초한 수학적인 연산을 테이블에 대해 실행

## 58. ERD(Entity Relationship Diagram)
- 개체관계도 : 말로 되어있는 요구분석사항을 그림으로 그려 그 관계를 도출하는 것

## 59. Index
- 장점 : 가장 큰 장점은 데이터의 빠른 검색이고, 다음은 Row의 유일성의 유지
- 단점 : 인덱스를 만들면 그 정보의 유지를 위한 디스크 공간이 필요하고, 인덱스가 걸려있는 테이블은 인덱스가 없을 때보다 데이터 추가나 변경할 때 많은 시간이 소요
- 인덱스의 종류
  - Unique Clustered Index
  - Nonunique Clustered Index
  - Unique Nonclustered Index
  - Nonunique Nonclustered Index
  - Clustered Index
    - 한 테이블에 단 한 개만 존재
    - 범위(Range)를 주어 검색할 때 탁월한 기능 발휘
    - (예) 키순으로 서세요. 나이순으로 서세요. 이름순으로 서세요.
  - Nonclustered Index
    - 한 테이블에 여러 개 존재 가능
    - 특정한 값으로 찾아갈 때(Seek) 탁월한 성능 발휘
    - (예) 도서명, 저자명, 분야명
  
## 60. 트랜잭션, 롤백, 커밋
- 트랜잭션 : 
  - 일련의 작업단위
  - 특성으로 ACID(원자성, 일관성, 고립성, 영구성)가 있음
  - 필요성 : 여러 작업이 한 자원에서 동시에 변경, 참조 필요시/작업공정이 긴 경우
  - 시작 : 
    - 첫 DML(data조작어)구문이 실행될 때(SELECT에선 제외)
    - 사용자가 ASVEPOINT를 설정할 때
   - 종료 : 
     - commit 수행
     - rollback 수행
     - 오라클 내부에서 자동 commit 수정
     - DDL(data조작어), DCL(data제어어)이 실행될 때
     - 사용자가 sqlplus를 종료할 때, 시스템 크래쉬 발생
- 커밋과 롤백 전 :
  - 롤백으로 데이터 회복 가능
  - 현재 유저는 자신이 바꾼 데이터 확인 가능
    - 다른 유제에게는 바뀐 데이터 내용이 반영되지 않음
    - 영향받은 레코드는 잠금 상태
- 커밋 후 :
  - 데이터는 영구적으로 변경
  - 복구 불가능
  - 세이브 포인트 삭제
  - 모든 유저에게 변경 내용 반영
  - 해당 레코드 잠금 해제, 다른 유저들이 다룰 수 있음
- 롤백 후 : 
  - 데이터의 변경 취소
  - 데이터 이전 상태 회복 
  - 데이터에 대한 잠금 해제

## 61. DB정규화의 목적
- 자료정규화 작업의 가장 큰 목적은 자료저장의 중복성 배제
- 정규화 이론에서는 릴레이션 형태가 여러 단계로 구분되며, 가장 기본적인 정규화 조건도 만족하지 못하는 릴레이션을 비정규형, 만족하는 릴레이션을 제1정규형이라고 부름
- 조건이 점점 엄격해짐에 따라 제2, 제3, 제4, 제5정규형으로 구분됨
- 높은 단계의 정규형으로 나아갈수록 데이터의 본질적 의미가 릴레이션 구조에 보다 정확히 반영되고, 데이터 중복을 줄이고, 데이터 변경 시 발생하는 문제점을 방지하고, 궁극적으로 데이타 무결성(data integrity)을 제고할 수 있다고 가정함

## 62. ACID(Atomic Consistent Isolated Durable)
- 원자성, 일관성, 독립성, 지속성의 약어
- 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질
  
## 63. DDL(Data Definition Language)
- 테이블 및 객체의 구조 생성 그리고 삭제, 변경과 관련된 명령어
  - CRATE : 새로운 테이블 생성
  - DROP : 기존 테이블의 구조 및 모든 행을 삭제
  - ALTER : 기존 테이블 변경, 필드를 추가 또는 수정할 수 있지만 삭제 불가
  - TRUNCATE : 테이블의 구조를 남기고 모든 데이터 삭제
  - RENAME : 오브젝트의 이름을 변경
  - COMMENT : 테이블이나 컬럼에 주석문
  
## 64. DML(Data Manipulation Language)
- 데이터 조작과 관계된 명령어
- 데이터의 검색 및 출력, 정렬과 조인에 관계됨
  - SELECT : 데이터의 조회
  - INSERT : 데이터의 입력
  - UPDATE : 데이터의 수정
  - DELETE : 데이터의 삭제
  - WHERE : 데이터의 조건
 
## 65. DCL(Data Control Language)
- 계정의 권한과 관계된 명령어
- DB 사용자의 권한 정의
  - COMMIT : 데이터베이스 조작을 영구적으로 반영
  - ROLLBACK : 마지막 COMMIT 상태로 복구
  - GRANT : 권한 부여
  - REVOKE : 권한 취소

## 66. Struts2
- MVC 패턴을 지원하고, 웹 어플리케이션을 개발하기 위한 프레임워크
- Struts1 + Webwork2의 아키텍처 적용
- POJO (Plain Old Java Object) 기반 액션 사용
- Zero configuration (설정 없이) 지향
- Ajax기능을 태그와 테마 기반으로 구성
- 다양한 표현식 언어 사용 가능 (JSTL, OGNL)
- MVC 모델에서 커버하는 부분 : Controller 지원
- 실행 순서 (실행 구조)
  - web.xml의 등록된 FilterDispatcher를 통해서 요청에 대해 진입
  - FilterDispatcher에선 모든 요청을 처리하고, ActionPloxy 생성
  - ActionPloxy가 생성되면 FilterDispatcher가 실행 권한을 위임
  - configuration은 Struts.xml을 통해서 설정관리자를 초기화함
  - 초기화 후, Action invocation 실행
  - 실행할 Interceptor가 있으면 실행하고, Action으로 전달
  - Action에서 결과값을 통해, 해당 Template로 이동
  - Interceptor자원 반납 후 응답

## 67. C와 C++의 차이점
- C : 
  - 함수 기반.
  - 절차함수 기능만 가지고 있음
  - 필요하면 함수 prototype을 만들어서 본문 추가
- C++ : 
  - 클래스 기반
  - 컴파일러 단에서 “클래스”라는 객체지향적 방법을 지원
  - 클래스에서 생성자/소멸자 등을 사용하여 자원 관리를 자동화할 수 있음
  - 연산자 재정의가 가능

## 68. OSI 7 Layers(OSI 7 계층 구조)
- 7계층: 응용 계층 (application layer)
- 6계층: 표현 계층 (presentation layer)
- 5계층: 세션 계층 (session layer)
- 4계층: 전송 계층 (transport layer)
- 3계층: 네트워크 계층 (network layer)
- 2계층: 데이터링크 계층 (data link layer)
- 1계층: 물리 계층 (physical layer)

## 69. Stack과 Queue
- Stack과 Queue는 컴퓨터의 알고리즘에서 가장 흔하게 사용되는 자료 구조
- Stack : 
  - 모든 작업이 리스트의 한 쪽 끝에서만 수행되는 선형 리스트의 한 형태
  - 리스트의 한 쪽 끝(TOP)에서 원소를 삽입하거나 제거하는데 사용
  - 리스트에서 Stack에 마지막으로 입력된 원소가 제일 먼저 제거의 대상이 됨
  - Stack을 LIFO (Last in First Out) 라고 함

- Queue 방식 : 
  - 삽입은 REAR에서 이루어지고, 제거는 FRONT에서 이루어짐
  - Queue에 A, B, C, D, E 순으로 원소가 삽입되었다면, 제일 먼저 제거되는 원소는 A
  - Queue는 FIFO (First in First Out) 라고 함
  
## 70. AJAX
- 웹 클라이언트 화면 제어를 보다 세밀하게 하기 위한 기술
- 필요한 데이터만 서버로 보내고 해당 정보만 받음
- 서버로부터 정보를 받을 때는 xml or josn 형태로 받고, Client에서는 그 정보들을 DOM을 통해 화면을 재가공하여 보여주므로 서버와 교환되는 데이터의 양이 적어지므로 점유율을 낮출 수 있음
- Client에서의 데이터 처리로 서버에 부담이 덜 가므로 다른 응답 요청에 신속히 응대
